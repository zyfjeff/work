* Hazard Pointer

简称HP，核心要解决的问题是怎么样安全的释放内存。

1. 保证了关键节点的访问是合法的，不会导致程序尝试去读取已经释放了的内存。
2. 保证了 ABA 问题不会出现，程序逻辑正确的前提。

在无锁算法中释放内存之所以难，主要原因在于，当一个线程准备释放一块内存时，它无法知道是否另有别的线程也同时持有该块内存的指针并需要访问，因此解决这个难点的一个直接想法就是，在每个线程获取了一个关键内存的指针后，该线程将设置一个标志，
表明"我正在操作这个关键数据，你们谁都别给我随便就释放了"。当然，这个标志需要放在一个公共区域，使得任何线程都可以去读。当另一个线程想要释放一块内存时，它就去把每个线程的标志都看一下，
看看是否有别的线程也在操作这块内存，从而决定是否马上释放该内存：如果有别的线程在操作该内存，则暂时不释放，等下次。具体实现如下：

1. 建立一个全局数组 HP hp[N]，数组中的元素为指针，称为 Hazard pointer，数组的大小为线程的数目，即每个线程拥有一个 HP。
2. 约定每个线程只能修改自己的 HP，而不允许修改别的线程的 HP，但可以去读别的线程的 HP 值。
3. 当线程尝试去访问一个关键数据节点时，它得先把该节点的指针赋给自己的 HP，即告诉别人不要释放这个节点。
4. 每个线程维护一个私有链表(free list)，当该线程准备释放一个节点时，把该节点放入自己的链表中，当链表数目达到一个设定数目 R 后，遍历该链表把能释放的节点通通释放。
5. 当一个线程要释放某个节点时，它需要检查全局的 HP 数组，确定如果没有任何一个线程的 HP 值与当前节点的指针相同，则释放之，否则不释放，仍旧把该节点放回自己的链表中。


* Quiescent-State-Based Reclamation(QSBR)

Linux内核中的RCU属于这个类型
