1. T 只包含所有权类型

范型中的T是任意类型(所有权、引用、可变引用)，而不只是基本的所有权类型。不要认为`T`包含一切所有权类型； `&T` 包含一切不可变借用类型； `&mut T` 包含一切可变借用类型。
T, &T, 和 &mut T 都是无限集, 因为你可以无限借用一个类型。 T 是 &T 和 &mut T的超集. &T 和 &mut T 是不相交的集合。

```rust

    // T 包含了&T，两者是包含关系，所以不能这么做，
    // &T和&mu T 是互斥关系，因此是可以的。
    trait Trait {}
    // impl<T> Trait for T {}
    impl<T> Trait for &T {}
    impl<T> Trait for &mut T {}
```

2. 如果 `T: 'static` 那么 `T` 必须在整个程序运行中都是有效的

    * `T: 'static` 并不是指T拥有`'static`生命周期
    * `&'static T`和`T: 'static`是有区别的
    * `T: 'static`并不代表T一定是不可变的
    * `T: 'static`并不代表T只能在编译期创建

`&'static T`是对某个`T`的不可变引用，这个引用可以被无限期地持有直到程序结束。这只可能发生在T本身不可变且不会在引用被创建后移动的情况下。 T并不需要在编译期就被创建，因为我们可以在运行时动态生成随机数据， 然后以内存泄漏为代价返回`'static`引用。

```rust
use rand;

// 在运行时生成随机&'static str
fn rand_str_generator() -> &'static str {
    let rand_string = rand::random::<u64>().to_string();
    Box::leak(rand_string.into_boxed_str())
}
```

`T: 'static` 是指T可以被无限期安全地持有直到程序结束。 `T: 'static`包括所有`&'static T`，此外还包括所有的所有权类型，比如`String`, `Vec`等。数据的所有者能够保证数据只要还被持有就不会失效，因此所有者可以无限期安全地持有该数据直到程序结束。 `T: 'static`应该被看作“`T`受`'static`生命周期约束”而非“T有着'`static`生命周期”`

3. `&'a T` 和 `T: 'a` 是相同的

`&'a T`不光要求，同时有隐含着`T: 'a`，`T: 'a`包括了所有`&'a T`，但反过来不对。

```rust
// 只接受以'a约束的引用类型
fn t_ref<'a, T: 'a>(t: &'a T) {}

// 接受所有以'a约束的类型
fn t_bound<'a, T: 'a>(t: T) {}

// 包含引用的所有权类型
struct Ref<'a, T: 'a>(&'a T);

fn main() {
    let string = String::from("string");

    t_bound(&string); // 编译通过
    t_bound(Ref(&string)); // 编译通过
    t_bound(&Ref(&string)); // 编译通过

    t_ref(&string); // 编译通过
    t_ref(Ref(&string)); // 编译错误, 期待接收一个引用，但收到一个结构体
    t_ref(&Ref(&string)); // 编译通过

    // string变量是以'static约束的，也满足'a约束
    t_bound(string); // 编译通过
}
```

  * `T: 'a` 比起 `&'a T`更泛化也更灵活
  * `T:'a` 可以接收所有权类型、包含引用的所有权类型、以及引用类型
  * `&'a T` 只能接收引用类型
  * 如果 `T: 'static` 那么 `T: 'a`, 因为对于所有`'a`都有`'static >= 'a`

4. 我的代码没用到泛型，也不含生命周期
  
  * 避免使用泛型和生命周期是可能的
  * 每个传入的引用都会有一个单独的生命周期
  * 如果只有一个传入的生命周期，那么它将被应用到所有输出的引用上
  * 如果有多个传入的生命周期，但其中一个是&self或者&mut self，那么这个生命周期将会被应用到所有输出的引用上
  * 除此之外的输出的生命周期都必须显示标注出来

```rust
        // fn print(s: &str)    省略了生命周期，每一个传入的引用都有一个生命周期
        // 展开 fn print<'a>(s: &'a str)

        // fn trim(s: &str) -> &str 省略了输入和输出的生命周期
        // 展开 fn trim<'a>(s: &'a str) -> &'a str


        // 不合法，无法确定输出的生命周期，因为没有输入，需要显示的给予生命周期
        // fn get_str() -> &str
        // 显示 fn get_str<'a>() -> &'a str;
        // fn get_str() -> &'static str;

        // fn overlap(s: &str, t: &str) -> &str 不合法，无法确定输出的生命周期，因为这里有多个输入
        // 显示
        // fn overlap<'a>(s: &'a str, t: &str) -> &'a str; 输出生命周期不能长于s
        // fn overlap<'a>(s: & str, t: &'a str) -> &'a str;  输出生命周期不能长于t
        // fn overlap<'a>(s: &'a str, t: &'a str) -> &'a str 出生命周期不能长于s和t
        // fn overlap(s: &str, t: &str) -> &'static str; 输出生命周期可以长于s和t
        // fn overlap<'a>(s: &str, t: &str) -> &'a str; 输入和输出的生命周期无关

        // 展开
        // fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'a str;
        // fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'b str;
        // fn overlap<'a>(s: &'a str, t: &'a str) -> &'a str;
        // fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'static str;
        // fn overlap<'a, 'b, 'c>(s: &'a str, t: &'b str) -> &'c str;

        // 省略
        // fn compare(&self, s: &str) -> &str;

        // 展开
        // fn compare<'a, 'b>(&'a self, &'b str) -> &'a str;
```

5. 如果编译能通过，那么我的生命周期标注就是正确的